# ポリシーエンジン

:::note この機能は現在テスト中です。有効にするには、`settings.json` ファイルで `tools.enableMessageBusIntegration` を `true` に設定してください。:::

Gemini CLI には、ツール実行をきめ細かく制御できる強力なポリシーエンジンが含まれています。これにより、ユーザーと管理者は、ツール呼び出しを許可するか、拒否するか、またはユーザー確認を要求するかを決定するルールを定義できます。

## コアコンセプト

ポリシーエンジンは、一連のルールに基づいて動作します。各ルールは、条件と結果の決定の組み合わせです。大規模言語モデルがツールを実行したい場合、ポリシーエンジンはすべてのルールを評価し、ツール呼び出しに一致する最高優先順位のルールを見つけます。

ルールは、次の主要コンポーネントで構成されます。

- **条件**: ルールを適用するためにツール呼び出しが満たす必要がある基準。これには、ツールの名前、それに提供される引数、または現在の承認モードが含まれます。
- **決定**: ルールが一致した場合に実行するアクション（`allow`、`deny`、または `ask_user`）。
- **優先順位**: ルールの優先順位を決定する数値。数値が大きいほど優先されます。

たとえば、このルールは `git` コマンドを実行する前にユーザー確認を求めます。

```toml
[[rule]]
toolName = "run_shell_command"
commandPrefix = "git "
decision = "ask_user"
priority = 100
```

### 条件

条件は、ルールを適用するためにツール呼び出しが満たす必要がある基準です。主要な条件は、ツールの名前とその引数です。

#### ツール名

ルールの `toolName` は、呼び出されているツールの名前と一致する必要があります。

- **ワイルドカード**: モデルホスティングプロトコル (MCP) サーバーの場合、ワイルドカードを使用できます。`toolName` が `my-server__*` の場合、`my-server` MCP のすべてのツールと一致します。

#### 引数パターン

`argsPattern` が指定されている場合、ツールの引数は安定した JSON 文字列に変換され、提供された正規表現に対してテストされます。引数がパターンと一致しない場合、ルールは適用されません。

### 決定

ルールが強制できる決定は3つあります。

- `allow`: ユーザーとの対話なしにツール呼び出しが自動的に実行されます。
- `deny`: ツール呼び出しはブロックされ、実行されません。
- `ask_user`: ユーザーはツール呼び出しを承認または拒否するよう求められます。（非対話モードでは、これは `deny` として扱われます。）

### 優先順位システムとティア

ポリシーエンジンは、複数のルールが単一のツール呼び出しに一致する場合に競合を解決するために、洗練された優先順位システムを使用します。コア原則は単純です。**優先順位が最も高いルールが優先されます。**

明確な階層を提供するために、ポリシーは3つのティアに編成されています。各ティアには、最終的な優先順位計算のベースとなる指定された数値があります。

| ティア    | ベース | 説明                                                                |
| :------ | :--- | :------------------------------------------------------------------------- |
| デフォルト | 1    | Gemini CLI に付属している組み込みポリシー。                           |
| ユーザー    | 2    | ユーザーが定義するカスタムポリシー。                                       |
| 管理者    | 3    | 管理者によって管理されるポリシー（例: エンタープライズ環境）。 |

TOML ポリシーファイル内で、**0から999**までの優先順位値を割り当てます。エンジンは、次の式を使用してこれを最終的な優先順位に変換します。

`final_priority = tier_base + (toml_priority / 1000)`

このシステムは以下を保証します。

- 管理者ポリシーは常にユーザーポリシーとデフォルトポリシーをオーバーライドします。
- ユーザーポリシーは常にデフォルトポリシーをオーバーライドします。
- 単一のティア内でも、きめ細かな制御でルールを順序付けできます。

例:

- デフォルトポリシーファイルの `priority: 50` ルールは `1.050` になります。
- ユーザーポリシーファイルの `priority: 100` ルールは `2.100` になります。
- 管理者ポリシーファイルの `priority: 20` ルールは `3.020` になります。

### 承認モード

承認モードにより、ポリシーエンジンは CLI の動作モードに基づいて異なるルールセットを適用できます。ルールは1つ以上のモード（例: `yolo`、`autoEdit`）に関連付けることができます。ルールは、CLI が指定されたいずれかのモードで実行されている場合にのみアクティブになります。ルールにモードが指定されていない場合、常にアクティブになります。

## ルールマッチング

ツール呼び出しが行われると、エンジンはアクティブなすべてのルールに対して、最も優先順位の高いものから順にチェックします。最初に一致するルールが結果を決定します。

ルールは、すべての条件が満たされた場合にツール呼び出しと一致します。

1.  **ツール名**: ルールの `toolName` は、呼び出されているツールの名前と一致する必要があります。
    - **ワイルドカード**: モデルホスティングプロトコル (MCP) サーバーの場合、ワイルドカードを使用できます。`toolName` が `my-server__*` の場合、`my-server` MCP のすべてのツールと一致します。
2.  **引数パターン**: `argsPattern` が指定されている場合、ツールの引数は安定した JSON 文字列に変換され、提供された正規表現に対してテストされます。引数がパターンと一致しない場合、ルールは適用されません。

## 構成

ポリシーは `.toml` ファイルで定義されます。CLI は、これらのファイルをデフォルト、ユーザー、および（構成されている場合は）管理者ディレクトリからロードします。

### TOML ルールスキーマ

TOML ポリシールールで利用可能なフィールドの内訳を次に示します。

```toml
[[rule]]
# ツールのユニークな名前、または名前の配列。
toolName = "run_shell_command"

# (オプション) MCP サーバーの名前。toolName と組み合わせて、
# "mcpName__toolName" のような複合名を形成できます。
mcpName = "my-custom-server"

# (オプション) ツールの引数と一致する正規表現。
argsPattern = '"command":"(git|npm)'

# (オプション) シェルコマンドが開始する必要がある文字列または文字列の配列。
# これは、`toolName = "run_shell_command"` と `argsPattern` のシンタックスシュガーです。
commandPrefix = "git "

# (オプション) シェルコマンド全体と一致する正規表現。
# これは、`toolName = "run_shell_command"` のシンタックスシュガーでもあります。
# 注: このパターンは引数の JSON 表現（例: `{"command":"<your_command>"}`)に対してテストされるため、`^` や `$` のようなアンカーは、コマンドテキストだけでなく、完全な JSON 文字列に適用されます。
# 同じルールで commandPrefix と commandRegex を使用することはできません。
commandRegex = "^git (commit|push)"

# 実行する決定。`"allow"`、`"deny"`、または `"ask_user"` のいずれかである必要があります。
decision = "ask_user"

# ルールの優先順位、0から999まで。
priority = 10

# (オプション) このルールがアクティブな承認モードの配列。
modes = ["autoEdit"]
```

### 配列（リスト）の使用

複数のツールまたはコマンドプレフィックスに同じルールを適用するには、`toolName` および `commandPrefix` フィールドに文字列の配列を提供できます。

**例:**

この単一のルールは、`write_file` ツールと `replace` ツールの両方に適用されます。

```toml
[[rule]]
toolName = ["write_file", "replace"]
decision = "ask_user"
priority = 10
```

### `run_shell_command` の特殊構文

`run_shell_command` のポリシーの記述を簡素化するために、より複雑な `argsPattern` の代わりに `commandPrefix` または `commandRegex` を使用できます。

- `commandPrefix`: `command` 引数が指定された文字列で始まる場合に一致します。
- `commandRegex`: `command` 引数が指定された正規表現に一致する場合に一致します。

**例:**

このルールは、`git` コマンドを実行する前にユーザー確認を求めます。

```toml
[[rule]]
toolName = "run_shell_command"
commandPrefix = "git "
decision = "ask_user"
priority = 100
```

### MCP ツールの特殊構文

`mcpName` フィールドまたはワイルドカードパターンを使用して、Model-hosting-protocol (MCP) サーバーからのツールをターゲットとするルールを作成できます。

**1. `mcpName` の使用**

特定のサーバーからの特定のツールをターゲットにするには、`mcpName` と `toolName` を組み合わせます。

```toml
# `my-jira-server` MCP の `search` ツールを許可する
[[rule]]
mcpName = "my-jira-server"
toolName = "search"
decision = "allow"
priority = 200
```

**2. ワイルドカードの使用**

特定の MCP サーバー上の_すべての_ツールに適用されるルールを作成するには、`mcpName` のみを指定します。

```toml
# `untrusted-server` MCP のすべてのツールを拒否する
[[rule]]
mcpName = "untrusted-server"
decision = "deny"
priority = 500
```

## デフォルトポリシー

Gemini CLI には、安全なすぐに使える体験を提供するための一連のデフォルトポリシーが付属しています。

- **読み取り専用ツール**（`read_file`、`glob` など）は通常**許可**されます。
- **書き込みツール**（`write_file`、`run_shell_command` など）はデフォルトで**`ask_user`**になります。
- **`yolo`** モードでは、高優先度のルールがすべてのツールを許可します。
- **`autoEdit`** モードでは、ルールは特定の書き込み操作がプロンプトなしで発生することを許可します。