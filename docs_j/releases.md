# Gemini CLI リリース

## `dev` と `prod` 環境

当社のリリースフローは、`dev` 環境と `prod` 環境の両方をサポートしています。

`dev` 環境は、プライベートな GitHub ホスト型 NPM リポジリへのプッシュと、パッケージ名が `@google/**` ではなく `@google-gemini/**` で始まることを行います。

`prod` 環境は、`@google/**` 名前空間の NPM パッケージを管理するための Google のシステムである Wombat Dressing Room を介して、パブリックなグローバル NPM レジストリにプッシュします。パッケージはすべて `@google/**` という名前です。

これらのシステムに関する詳細情報は、[メンテナーリポジトリガイド](https://github.com/google-gemini/maintainers-gemini-cli/blob/main/npm.md)で確認できます。

### パッケージスコープ

| パッケージ    | `prod` (Wombat Dressing Room) | `dev` (GitHub プライベート NPM リポジリ)           |
| ---------- | ----------------------------- | ---------------------------------------- |
| CLI        | @google/gemini-cli            | @google-gemini/gemini-cli                 |
| Core       | @google/gemini-cli-core       | @google-gemini/gemini-cli-core A2A Server |
| A2A Server | @google/gemini-cli-a2a-server | @google-gemini/gemini-cli-a2a-server      |

## リリースサイクルとタグ

当社は https://semver.org/ を可能な限り厳密に遵守しますが、逸脱する必要がある場合はその旨を明記します。毎週のリリースはマイナーバージョンアップとなり、リリース間のバグ修正やホットフィックスは、最新リリースに対するパッチバージョンとしてリリースされます。

毎週火曜日約UTC 2000に、新しい安定版とプレビュー版がリリースされます。プロモーションフローは次のとおりです。

- コードは main にコミットされ、毎晩 nightly にプッシュされます。
- main で最大1週間経過後、コードは `preview` チャネルにプロモーションされます。
- 1週間後、最新の `preview` チャネルが `stable` チャネルにプロモーションされます。
- パッチ修正は、必要に応じて `preview` と `stable` の両方に対して生成され、最後の「パッチ」バージョン番号は毎回インクリメントされます。

### プレビュー

これらのリリースは完全に検証されておらず、回帰やその他の未解決の問題が含まれている可能性があります。テストにご協力ください。`preview` タグでインストールします。

```bash
npm install -g @google/gemini-cli@preview
```

### 安定版

これは、先週のリリースの完全なプロモーションに加えて、バグ修正と検証が完了したものです。`latest` タグを使用します。

```bash
npm install -g @google/gemini-cli@latest
```

### ナイトリー

- 新しいリリースは毎日UTC 0000に公開されます。これは、リリース時点の main ブランチからのすべての変更を含みます。保留中の検証や問題がある可能性があることを前提としてください。`nightly` タグを使用します。

```bash
npm install -g @google/gemini-cli@nightly
```

## 毎週のリリースプロモーション

毎週火曜日、オンコールエンジニアは「Promote Release」ワークフローをトリガーします。この単一のアクションが、毎週のリリースプロセス全体を自動化します。

1.  **プレビューから安定版へのプロモーション:** ワークフローは最新の `preview` リリースを特定し、`stable` にプロモーションします。これが npm の新しい `latest` バージョンになります。
2.  **ナイトリーからプレビューへのプロモーション:** 最新の `nightly` リリースは、新しい `preview` バージョンとしてプロモーションされます。
3.  **次期ナイトリー準備:** 次期ナイトリーリリースに備えて、`main` のバージョンを上げるためのプルリクエストが自動的に作成され、マージされます。

このプロセスにより、最小限の手動介入で一貫性のある信頼性の高いリリースサイクルが保証されます。

### バージョン管理の信頼できる情報源

最高の信頼性を確保するために、リリースプロモーションプロセスでは、各リリースチャネル（`stable`、`preview`、`nightly`）の現在のバージョンを決定するために、**NPM レジストリを唯一の信頼できる情報源**として使用します。

1.  **NPM からフェッチ:** ワークフローは、NPM の `dist-tags`（`latest`、`preview`、`nightly`）をクエリして、現在ユーザーが利用できるパッケージの正確なバージョン文字列を取得することから始まります。
2.  **整合性のクロスチェック:** NPM から取得された各バージョンについて、ワークフローは重要な整合性チェックを実行します。
    - リポジリに**対応する Git タグ**が存在することを確認します。
    - **対応する GitHub リリース**が作成されていることを確認します。
3.  **不一致時の停止:** NPM にリストされているバージョンの Git タグまたは GitHub リリースのいずれかが不足している場合、ワークフローは直ちに失敗します。この厳密なチェックにより、破損または不完全な以前のリリースからのプロモーションが防止され、オンコールエンジニアに手動で解決する必要があるリリース状態の不整合を警告します。
4.  **次期バージョンの計算:** これらのチェックがすべてパスした後で初めて、ワークフローは NPM から取得された信頼できるバージョン番号に基づいて次期セマンティックバージョンを計算するに進みます。

この NPM ファーストのアプローチは、整合性チェックによって裏打ちされており、リリースプロセスを非常に堅牢にし、Git履歴やAPI出力のみに依存することによって発生する可能性のあるバージョン管理の不一致を防ぎます。

## 手動リリース

通常のナイトリーおよび毎週のプロモーションスケジュール外で、パッチ適用プロセスによってまだカバーされていないリリースが必要な状況では、`Release: Manual` ワークフローを使用できます。このワークフローは、任意のブランチ、タグ、またはコミット SHA から特定のバージョンを公開する直接的な方法を提供します。

### 手動リリースを作成する方法

1.  リポジリの **Actions** タブに移動します。
2.  リストから **Release: Manual** ワークフローを選択します。
3.  **Run workflow** ドロップダウンボタンをクリックします。
4.  必要な入力を記入します。
    - **Version**: リリースする正確なバージョン（例: `v0.6.1`）。これは `v` プレフィックスを持つ有効なセマンティックバージョンである必要があります。
    - **Ref**: リリース元のブランチ、タグ、または完全なコミット SHA。
    - **NPM Channel**: 公開する npm チャネル。オプションは `preview`、`nightly`、`latest`（安定版リリース用）、`dev` です。デフォルトは `dev` です。
    - **Dry Run**: 公開せずにすべてのステップを実行するには `true` のままにするか、ライブリリースを実行するには `false` に設定します。
    - **Force Skip Tests**: テストスイートをスキップするには `true` に設定します。これは本番リリースでは推奨されません。
    - **Skip GitHub Release**: GitHub リリースの作成をスキップし、npm リリースのみを作成するには `true` に設定します。
    - **Environment**: 適切な環境を選択します。`dev` 環境はテスト用です。`prod` 環境は本番リリース用です。`prod` がデフォルトであり、リリース管理者からの承認が必要です。
5.  **Run workflow** をクリックします。

ワークフローは、テスト（スキップされない場合）、ビルド、およびリリースの公開に進みます。ドライランではない実行中にワークフローが失敗した場合、失敗の詳細を含む GitHub Issue が自動的に作成されます。

## ロールバック/ロールフォワード

リリースに重大な回帰が発生した場合、npm `dist-tag` を変更することで、以前の安定バージョンに迅速にロールバックしたり、新しいパッチにロールフォワードしたりできます。`Release: Change Tags` ワークフローは、これを安全かつ制御された方法で行うことができます。

これは、フルリリースサイクルを必要としないため、ロールバックとロールフォワードの両方に推奨される方法です。

### リリースタグを変更する方法

1.  リポジリの **Actions** タブに移動します。
2.  リストから **Release: Change Tags** ワークフローを選択します。
3.  **Run workflow** ドロップダウンボタンをクリックします。
4.  必要な入力を記入します。
    - **Version**: タグを指す既存のパッケージバージョン（例: `0.5.0-preview-2`）。このバージョンは npm レジストリに**既に公開されている**必要があります。
    - **Channel**: 適用する npm `dist-tag`（例: `preview`、`stable`）。
    - **Dry Run**: 変更を行わずにアクションをログに記録するには `true` のままにするか、ライブタグ変更を実行するには `false` に設定します。
    - **Environment**: 適切な環境を選択します。`dev` 環境はテスト用です。`prod` 環境は本番リリース用です。`prod` がデフォルトであり、リリース管理者からの承認が必要です。
5.  **Run workflow** をクリックします。

ワークフローは、指定されたチャネルを指定されたバージョンにポイントする、適切な `gemini-cli`、`gemini-cli-core`、および `gemini-cli-a2a-server` パッケージの `npm dist-tag add` を実行します。

## パッチ適用

`main` で既に修正されている重大なバグを `stable` または `preview` リリースにパッチ適用する必要がある場合、プロセスは高度に自動化されています。

### パッチ適用方法

#### 1. パッチプルリクエストを作成

パッチプルリクエストを作成するには、2つの方法があります。

**オプションA: GitHubコメントから（推奨）**

修正を含むプルリクエストがマージされた後、メンテナーはその同じPRに次の形式のコメントを追加できます。

`/patch [channel]`

- **channel** (オプション):
  - _チャネルなし_ - stable と preview の両方のチャネルにパッチを適用します（デフォルト、ほとんどの修正に推奨）
  - `both` - stable と preview の両方のチャネルにパッチを適用します（デフォルトと同じ）
  - `stable` - stable チャネルのみにパッチを適用します
  - `preview` - preview チャネルのみにパッチを適用します

例:

- `/patch` (stable と preview の両方にパッチを適用 - デフォルト)
- `/patch both` (stable と preview の両方にパッチを適用 - 明示的)
- `/patch stable` (stable のみにパッチを適用)
- `/patch preview` (preview のみにパッチを適用)

`Release: Patch from Comment` ワークフローは、自動的にマージコミット SHA を見つけ、`Release: Patch (1) Create PR` ワークフローをトリガーします。PRがまだマージされていない場合は、失敗を示すコメントを投稿します。

**オプションB: ワークフローを手動でトリガー**

**Actions** タブに移動し、**Release: Patch (1) Create PR** ワークフローを実行します。

- **Commit**: チェリーピックしたい `main` 上のコミットの完全な SHA。
- **Channel**: パッチを適用したいチャネル（`stable` または `preview`）。

このワークフローは自動的に次のことを行います。

1.  チャネルの最新リリースタグを見つけます。
2.  そのタグからリリースブランチが存在しない場合は作成します（例: `release/v0.5.1-pr-12345`）。
3.  リリースブランチから新しいホットフィックスブランチを作成します。
4.  指定されたコミットをホットフィックスブランチにチェリーピックします。
5.  ホットフィックスブランチからリリースブランチへのプルリクエストを作成します。

#### 2. レビューとマージ

チェリーピックが成功し、変更が正しいことを確認するために、自動的に作成されたプルリクエストをレビューします。承認されたら、プルリクエストをマージします。

**セキュリティに関する注意:** `release/*` ブランチは、ブランチ保護ルールによって保護されています。これらのブランチへのプルリクエストには、マージされる前にコードオーナーによる少なくとも1回のレビューが必要です。これにより、不正なコードがリリースされるのを防ぎます。

#### 2.5. ホットフィックスに複数のコミットを追加する（上級者向け）

単一のパッチリリースに複数の修正を含める必要がある場合は、最初のパッチ PR が作成された後、ホットフィックスブランチに追加のコミットを追加できます。

1. **主要な修正から開始**: 最も重要なPRで `/patch`（または `/patch both`）を使用して、最初のホットフィックスブランチとPRを作成します。

2. **ホットフィックスブランチをローカルでチェックアウト**:

   ```bash
   git fetch origin
   git checkout hotfix/v0.5.1/stable/cherry-pick-abc1234  # PRの実際のブランチ名を使用
   ```

3. **追加のコミットをチェリーピック**:

   ```bash
   git cherry-pick <commit-sha-1>
   git cherry-pick <commit-sha-2>
   # 必要に応じてコミットを追加
   ```

4. **更新されたブランチをプッシュ**:

   ```bash
   git push origin hotfix/v0.5.1/stable/cherry-pick-abc1234
   ```

5. **テストとレビュー**: 既存のパッチPRは、追加のコミットで自動的に更新されます。複数の変更を同時にリリースするため、徹底的にテストしてください。

6. **PRの説明を更新**: PRのタイトルと説明を更新して、複数の修正が含まれていることを反映させることを検討してください。

このアプローチにより、関連する修正を単一のパッチリリースにグループ化しながら、何を含めるか、競合をどのように解決するかを完全に制御できます。

#### 3. 自動リリース

プルリクエストのマージ後、`Release: Patch (2) Trigger` ワークフローが自動的にトリガーされます。その後、`Release: Patch (3) Release` ワークフローが開始され、次のことを行います。

1.  パッチ適用されたコードをビルドしてテストします。
2.  新しいパッチバージョンを npm に公開します。
3.  パッチノート付きの新しい GitHub リリースを作成します。

この完全に自動化されたプロセスにより、パッチが常に一貫性のある信頼性の高い方法で作成およびリリースされることが保証されます。

#### トラブルシューティング: 古いブランチワークフロー

**問題**: パッチトリガーワークフローが「Resource not accessible by integration」などのエラー、または存在しないワークフローファイル（例: `patch-release.yml`）への参照で失敗する場合、これはホットフィックスブランチに古いバージョンのワークフローファイルが含まれていることを示します。

**根本原因**: PRがマージされると、GitHub Actions はターゲットブランチ（リリースブランチ）からではなく、**ソースブランチ**（ホットフィックスブランチ）のワークフロー定義を実行します。ワークフローの改善以前の古いリリースブランチからホットフィックスブランチが作成された場合、古いワークフローロジックが使用されます。

**解決策**:

**オプション1: 手動トリガー（クイックフィックス）** 最新のワークフローコードを含むブランチから更新されたワークフローを手動でトリガーします。

```bash
# テストをスキップしたプレビューチャネルパッチの場合
gh workflow run release-patch-2-trigger.yml --ref <branch-with-updated-workflow> \
  --field ref="hotfix/v0.6.0-preview.2/preview/cherry-pick-abc1234" \
  --field workflow_ref=<branch-with-updated-workflow> \
  --field dry_run=false \
  --field force_skip_tests=true

# 安定チャネルパッチの場合
gh workflow run release-patch-2-trigger.yml --ref <branch-with-updated-workflow> \
  --field ref="hotfix/v0.5.1/stable/cherry-pick-abc1234" \
  --field workflow_ref=<branch-with-updated-workflow> \
  --field dry_run=false \
  --field force_skip_tests=false

# main ブランチを使用する例（最も一般的なケース）
gh workflow run release-patch-2-trigger.yml --ref main \
  --field ref="hotfix/v0.6.0-preview.2/preview/cherry-pick-abc1234" \
  --field workflow_ref=main \
  --field dry_run=false \
  --field force_skip_tests=true
```

**注**: `<branch-with-updated-workflow>` を最新のワークフロー改善を含むブランチ（通常は `main` ですが、更新をテストしている場合は機能ブランチである可能性もあります）に置き換えてください。

**オプション2: ホットフィックスブランチを更新する** 最新の `main` ブランチをホットフィックスブランチにマージして、更新されたワークフローを取得します。

```bash
git checkout hotfix/v0.6.0-preview.2/preview/cherry-pick-abc1234
git merge main
git push
```

その後、PR を閉じて再度開き、更新されたバージョンでワークフローを再トリガーします。

**オプション3: 直接リリースをトリガーする** トリガーワークフローを完全にスキップして、リリースワークフローを直接実行します。

```bash
# channel と release_ref を適切な値に置き換える
gh workflow run release-patch-3-release.yml --ref main \
  --field type="preview" \
  --field dry_run=false \
  --field force_skip_tests=true \
  --field release_ref="release/v0.6.0-preview.2"
```

### Docker

Google Cloud Build も実行しています ([release-docker.yml](../.gcp/release-docker.yml))。これはサンドボックス Docker をリリースに合わせて公開します。これも GitHub に移動され、サービスアカウントのアクセス許可が解決され次第、メインのリリースファイルと結合されます。

## リリース検証

新しいリリースをプッシュした後、パッケージが期待どおりに機能していることを確認するためにスモークテストを実行する必要があります。これは、パッケージをローカルにインストールし、一連のテストを実行して、それらが正しく機能していることを確認することで実行できます。

- `npx -y @google/gemini-cli@latest --version` は、rc または dev タグを使用していない場合にプッシュが期待どおりに機能したことを検証します。
- `npx -y @google/gemini-cli@<release tag> --version` は、タグが適切にプッシュされたことを検証します。
- _これはローカルで破壊的です_
  `npm uninstall @google/gemini-cli && npm uninstall -g @google/gemini-cli && npm cache clean --force &&  npm install @google/gemini-cli@<version>`
- 予想通りにパッケージが機能していることを確認するために、いくつかの LLM コマンドとツールを実行する基本的なスモークテストを実行することをお勧めします。これは将来、さらに体系化される予定です。

## ローカルテストと検証: パッケージングおよび公開プロセスの変更

NPM に実際に公開したり、公開 GitHub リリースを作成したりせずにリリースプロセスをテストする必要がある場合は、GitHub UI からワークフローを手動でトリガーできます。

1.  リポジリの [Actions タブ](https://github.com/google-gemini/gemini-cli/actions/workflows/release-manual.yml)に移動します。
2.  「Run workflow」ドロップダウンをクリックします。
3.  `dry_run` オプションをチェックしたまま（`true`）にします。
4.  「Run workflow」ボタンをクリックします。

これにより、リリースプロセス全体が実行されますが、`npm publish` および `gh release create` ステップはスキップされます。ワークフローログを調べて、すべてが期待どおりに機能していることを確認できます。

パッケージングおよび公開プロセスへの変更をコミットする前にローカルでテストすることが重要です。これにより、パッケージが正しく公開され、ユーザーによってインストールされたときに期待どおりに機能することが保証されます。

変更を検証するには、公開プロセスのドライランを実行できます。これにより、パッケージを npm レジストリに実際に公開することなく、公開プロセスをシミュレートします。

```bash
npm_package_version=9.9.9 SANDBOX_IMAGE_REGISTRY="registry" SANDBOX_IMAGE_NAME="thename" npm run publish:npm --dry-run
```

このコマンドは次のことを行います。

1.  すべてのパッケージをビルドします。
2.  すべての prepublish スクリプトを実行します。
3.  npm に公開されるパッケージ tarball を作成します。
4.  公開されるパッケージの概要を出力します。

その後、生成された tarball を検査して、正しいファイルが含まれていること、および `package.json` ファイルが正しく更新されていることを確認できます。tarball は、各パッケージのディレクトリのルートに作成されます（例: `packages/cli/google-gemini-cli-0.1.6.tgz`）。

ドライランを実行することで、パッケージングプロセスへの変更が正しく、パッケージが正常に公開されることを確信できます。

## リリース詳細

リリースプロセスは、異なる配布チャネルのために2種類のアーティファクトを作成します。NPM レジストリ用の標準パッケージと、GitHub リリース用の単一の自己完結型実行可能ファイルです。

主な段階は次のとおりです。

**ステージ1: リリース前の健全性チェックとバージョン管理**

- **何が起こるか:** ファイルが移動される前に、プロセスはプロジェクトが良好な状態であることを確認します。これには、テスト、リンティング、タイプチェック（`npm run preflight`）の実行が含まれます。ルートの `package.json` と `packages/cli/package.json` のバージョン番号は、新しいリリースバージョンに更新されます。

**ステージ2: NPM 用のソースコードのビルド**

- **何が起こるか:** `packages/core/src` と `packages/cli/src` の TypeScript ソースコードは、標準の JavaScript にコンパイルされます。
- **ファイル移動:** 
  - `packages/core/src/**/*.ts` -> コンパイル先 -> `packages/core/dist/`
  - `packages/cli/src/**/*.ts` -> コンパイル先 -> `packages/cli/dist/`
- **理由:** 開発中に記述された TypeScript コードは、Node.js で実行できるプレーンな JavaScript に変換する必要があります。`cli` パッケージが `core` パッケージに依存しているため、`core` パッケージが最初にビルドされます。

**ステージ3: 標準パッケージの NPM への公開**

- **何が起こるか:** `@google/gemini-cli-core` および `@google/gemini-cli` パッケージに対して `npm publish` コマンドが実行されます。
- **理由:** これにより、標準の Node.js パッケージとして公開されます。`npm install -g @google/gemini-cli` を介してインストールするユーザーはこれらのパッケージをダウンロードし、`npm` は `@google/gemini-cli-core` の依存関係を自動的にインストールします。これらのパッケージのコードは単一のファイルにバンドルされません。

**ステージ4: GitHub リリースアセットの組み立てと作成**

このステージは NPM 公開_後_に行われ、GitHub リポジリから直接 `npx` 使用を可能にする単一ファイル実行可能ファイルを作成します。

1.  **JavaScript バンドルが作成されます:**
    - **何が起こるか:** `packages/core/dist` および `packages/cli/dist` からビルドされた JavaScript と、すべてのサードパーティ JavaScript 依存関係は、`esbuild` によって単一の実行可能 JavaScript ファイル（例: `gemini.js`）にバンドルされます。`node-pty` ライブラリはネイティブバイナリが含まれているため、このバンドルから除外されます。
    - **理由:** これにより、必要なすべてのアプリケーションコードを含む単一の最適化されたファイルが作成されます。`npm install` を完全に実行せずに CLI を実行したいユーザーにとって、すべての依存関係（`core` パッケージを含む）が直接含まれるため、実行が簡素化されます。

2.  **`bundle` ディレクトリが組み立てられます:**
    - **何が起こるか:** プロジェクトルートに一時的な `bundle` フォルダが作成されます。単一の `gemini.js` 実行可能ファイルと、その他の重要なファイルがその中に配置されます。
    - **ファイル移動:** 
      - `gemini.js` (esbuild から) -> `bundle/gemini.js`
      - `README.md` -> `bundle/README.md`
      - `LICENSE` -> `bundle/LICENSE`
      - `packages/cli/src/utils/*.sb` (サンドボックスプロファイル) -> `bundle/`
    - **理由:** これにより、CLI を実行し、そのライセンスと使用法を理解するために必要なすべてを含む、クリーンで自己完結型のディレクトリが作成されます。

3.  **GitHub リリースが作成されます:**
    - **何が起こるか:** `bundle` ディレクトリの内容（`gemini.js` 実行可能ファイルを含む）は、新しい GitHub リリースにアセットとして添付されます。
    - **理由:** これにより、CLI の単一ファイルバージョンが直接ダウンロードできるようになり、`npx https://github.com/google-gemini/gemini-cli` コマンドが有効になります。このコマンドは、この特定のバンドルされたアセットをダウンロードして実行します。

**アーティファクトの概要**

- **NPM:** 標準の、バンドルされていない Node.js パッケージを公開します。主なアーティファクトは `packages/cli/dist` のコードであり、`@google/gemini-cli-core` に依存します。
- **GitHub リリース:** `npx` を介して簡単に実行できるように、すべての依存関係を含む単一のバンドルされた `gemini.js` ファイルを公開します。

このデュアルアーティファクトプロセスにより、従来の `npm` ユーザーと `npx` の利便性を好むユーザーの両方が最適化されたエクスペリエンスを享受できます。

## 通知

リリースワークフローの失敗は、自動的に `release-failure` ラベル付きの Issue を作成します。

このタイプの Issue が作成されると、メンテナーのチャットチャネルに通知が投稿されます。

### チャット通知の変更

通知には [GitHub for Google Chat](https://workspace.google.com/marketplace/app/github_for_google_chat/536184076190) を使用します。通知を変更するには、チャットスペース内で `/github-settings` を使用します。

> [!WARNING] 以下の手順は、チャットアプリケーションの UI の内部構造に依存する脆弱な回避策を説明しています。将来のアップデートで破損する可能性があります。

利用可能なラベルのリストは、現在正しく入力されていません。リポジリの最初の30個のラベルにアルファベット順に表示されないラベルを追加したい場合は、ブラウザの開発者ツールを使用して UI を手動で変更する必要があります。

1.  ブラウザの開発者ツール（例: Chrome DevTools）を開きます。
2.  `/github-settings` ダイアログで、ラベルのリストを検査します。
3.  ラベルを表す `<li>` 要素のいずれかを見つけます。
4.  HTML で、その `<li>` 要素の `data-option-value` 属性を目的のラベル名（例: `release-failure`）に変更します。
5.  UI で変更したラベルをクリックして選択し、設定を保存します。