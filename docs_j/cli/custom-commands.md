# カスタムコマンド

カスタムコマンドを使用すると、お気に入りの、または最も頻繁に使用するプロンプトを Gemini CLI 内で個人のショートカットとして保存および再利用できます。単一のプロジェクトに固有のコマンドや、すべてのプロジェクトでグローバルに利用できるコマンドを作成でき、ワークフローを合理化し、一貫性を確保できます。

## ファイルの場所と優先順位

Gemini CLI は、特定の順序でロードされる2つの場所からコマンドを検出します。

1.  **ユーザーコマンド（グローバル）:** `~/.gemini/commands/` にあります。これらのコマンドは、作業中の任意のプロジェクトで利用できます。
2.  **プロジェクトコマンド（ローカル）:** `<your-project-root>/.gemini/commands/` にあります。これらのコマンドは現在のプロジェクトに固有であり、バージョン管理にチェックインしてチームと共有できます。

プロジェクトディレクトリ内のコマンドがユーザーディレクトリ内のコマンドと同じ名前を持つ場合、**常にプロジェクトコマンドが使用されます。** これにより、プロジェクトはグローバルコマンドをプロジェクト固有のバージョンでオーバーライドできます。

## 命名と名前空間

コマンドの名前は、`commands` ディレクトリに対する相対ファイルパスによって決定されます。サブディレクトリは名前空間コマンドを作成するために使用され、パス区切り文字（`/` または `\`）はコロン（`:`）に変換されます。

- `~/.gemini/commands/test.toml` のファイルは `/test` コマンドになります。
- `<project>/.gemini/commands/git/commit.toml` のファイルは、名前空間コマンド `/git:commit` になります。

## TOML ファイル形式 (v1)

コマンド定義ファイルは TOML 形式で記述し、`.toml` ファイル拡張子を使用する必要があります。

### 必須フィールド

- `prompt` (文字列): コマンド実行時に Gemini モデルに送信されるプロンプト。これは単一行または複数行の文字列にできます。

### オプションフィールド

- `description` (文字列): コマンドが行うことの簡潔な1行の説明。このテキストは、コマンドの横に `/help` メニューに表示されます。**このフィールドを省略すると、ファイル名から一般的な説明が生成されます。**

## 引数の処理

カスタムコマンドは、引数を処理するための2つの強力なメソッドをサポートしています。CLI は、コマンドの `prompt` の内容に基づいて正しいメソッドを自動的に選択します。

### 1. `{{args}}` を使用したコンテキスト認識型注入

`prompt` に特殊なプレースホルダー `{{args}}` が含まれている場合、CLI はそのプレースホルダーを、ユーザーがコマンド名の後にタイプしたテキストに置き換えます。

この注入の動作は、使用される場所によって異なります。

**A. 生の注入（シェルコマンド外）**

プロンプトのメインボディで使用される場合、引数はユーザーが入力したとおりに注入されます。

**例 (`git/fix.toml`):**

```toml
# 呼び出し方法: /git:fix "Button is misaligned"

description = "指定された問題の修正を生成します。"
prompt = "ここで説明されている問題のコード修正を提供してください: {{args}}。"
```

モデルは次を受け取ります。
`ここで説明されている問題のコード修正を提供してください: "Button is misaligned".`

**B. シェルコマンドでの引数の使用（`!{...}` ブロック内）**

シェル注入ブロック（`!{...}`）内で `{{args}}` を使用すると、引数は置き換え前に自動的に**シェルエスケープ**されます。これにより、引数をシェルコマンドに安全に渡し、結果のコマンドが構文的に正しく安全であることを保証し、コマンドインジェクションの脆弱性を防ぎます。

**例 (`/grep-code.toml`):**

```toml
prompt = """
Please summarize the findings for the pattern `{{args}}`.

Search Results:
!{grep -r {{args}} .}
"""
```

`/grep-code It's complicated` を実行すると:

1. CLI は `{{args}}` が `!{...}` の外部と内部の両方で使用されていることを認識します。
2. 外部: 最初の `{{args}}` は `It's complicated` でそのまま置き換えられます。
3. 内部: 2番目の `{{args}}` はエスケープされたバージョン（例: Linux で `"It's complicated"`）に置き換えられます。
4. 実行されるコマンドは `grep -r "It's complicated" .` です。
5. CLI は、実行前にこの正確で安全なコマンドを確認するプロンプトを表示します。
6. 最終プロンプトが送信されます。

### 2. デフォルトの引数処理

`prompt` に特殊なプレースホルダー `{{args}}` が**含まれていない**場合、CLI は引数を処理するためのデフォルトの動作を使用します。

コマンドに引数を提供した場合（例: `/mycommand arg1`）、CLI は、入力した完全なコマンドをプロンプトの末尾に2つの改行で区切って追加します。これにより、モデルは元の指示と提供した特定の引数の両方を確認できます。

引数を提供しなかった場合（例: `/mycommand`）、プロンプトは、何も追加されずにモデルにそのまま送信されます。

**例 (`changelog.toml`):**

この例は、モデルの役割を定義し、ユーザーの入力をどこで見つけるかを説明し、期待される形式と動作を指定することで、堅牢なコマンドを作成する方法を示しています。

```toml
# In: <project>/.gemini/commands/changelog.toml
# 呼び出し方法: /changelog 1.2.0 added "Support for default argument parsing."

description = "プロジェクトの CHANGELOG.md ファイルに新しいエントリを追加します。"
prompt = """
# タスク: 変更ログの更新

あなたはこのソフトウェアプロジェクトの専門メンテナーです。ユーザーが変更ログに新しいエントリを追加するコマンドを呼び出しました。

**ユーザーの生のコマンドは、あなたの指示の下に追加されます。**

あなたのタスクは、入力から `<version>`、`<change_type>`、`<message>` を解析し、`write_file` ツールを使用して `CHANGELOG.md` ファイルを正しく更新することです。

## 期待される形式
コマンドは次の形式に従います: `/changelog <version> <type> <message>`
- `<type>` は次のいずれかである必要があります: "added", "changed", "fixed", "removed".

## 動作
1. `CHANGELOG.md` ファイルを読み込みます。
2. 指定された `<version>` のセクションを見つけます。
3. 正しい `<type>` 見出しの下に `<message>` を追加します。
4. バージョンまたはタイプセクションが存在しない場合は作成します。
5. 「Keep a Changelog」形式に厳密に従ってください。
"""
```

`/changelog 1.2.0 added "New feature"` を実行すると、モデルに送信される最終テキストは、元のプロンプトの後に2つの改行と入力したコマンドが続くものになります。

### 3. `!{...}` でシェルコマンドを実行する

`prompt` 内でシェルコマンドを直接実行し、その出力を注入することで、コマンドを動的にすることができます。これは、ファイルコンテンツの読み取りや Git のステータスの確認など、ローカル環境からコンテキストを収集するのに最適です。

カスタムコマンドがシェルコマンドを実行しようとすると、Gemini CLI は続行する前に確認を求めます。これは、意図したコマンドのみが実行されることを保証するためのセキュリティ対策です。

**仕組み:**

1.  **コマンドを注入:** `!{...}` 構文を使用します。
2.  **引数置換:** ブロック内に `{{args}}` が存在する場合、自動的にシェルエスケープされます（上記の[コンテキスト認識型注入](#1-context-aware-injection-with-args)を参照）。
3.  **堅牢な解析:** パーサーは、JSON ペイロードなどのネストされたブレースを含む複雑なシェルコマンドを正しく処理します。**注:** `!{...}` 内のコンテンツは、バランスの取れたブレース（`{` と `}`）を持つ必要があります。バランスの取れていないブレースを含むコマンドを実行する必要がある場合は、外部スクリプトファイルでラップし、`!{...}` ブロック内でスクリプトを呼び出すことを検討してください。
4.  **セキュリティチェックと確認:** CLI は、最終的に解決されたコマンド（引数がエスケープされ置換された後）に対してセキュリティチェックを実行します。実行される正確なコマンドを示すダイアログが表示されます。
5.  **実行とエラー報告:** コマンドが実行されます。コマンドが失敗した場合、プロンプトに注入される出力には、エラーメッセージ（stderr）の後にステータス行（例: `[Shell command exited with code 1]`）が含まれます。これは、モデルが失敗のコンテキストを理解するのに役立ちます。

**例 (`git/commit.toml`):**

このコマンドは、ステージングされた Git diff を取得し、それを使用してモデルにコミットメッセージを記述するように依頼します。

````toml
# In: <project>/.gemini/commands/git/commit.toml
# 呼び出し方法: /git:commit

description = "ステージングされた変更に基づいて Git コミットメッセージを生成します。"

# プロンプトは !{...} を使用してコマンドを実行し、その出力を注入します。
prompt = """
次の Git diff に基づいて、Conventional Commit メッセージを生成してください。

```diff
!{git diff --staged}
```

"""

````

`/git:commit` を実行すると、CLI はまず `git diff --staged` を実行し、その出力を `!{git diff --staged}` と置き換えてから、最終的な完全なプロンプトをモデルに送信します。

### 4. `@{...}` でファイルコンテンツを注入する

`@{...}` 構文を使用して、ファイルまたはディレクトリリストのコンテンツをプロンプトに直接埋め込むことができます。これは、特定のファイルに対して操作するコマンドを作成するのに役立ちます。

**仕組み:**

- **ファイル注入**: `@{path/to/file.txt}` は `file.txt` のコンテンツに置き換えられます。
- **マルチモーダルサポート**: パスがサポートされている画像（例: PNG、JPEG）、PDF、音声、またはビデオファイルを指している場合、正しくエンコードされてマルチモーダル入力として注入されます。その他のバイナリファイルは適切に処理され、スキップされます。
- **ディレクトリリスト**: `@{path/to/dir}` は走査され、ディレクトリ内およびすべてのサブディレクトリ内に存在する各ファイルがプロンプトに挿入されます。これにより、有効になっている場合は `.gitignore` および `.geminiignore` が尊重されます。
- **ワークスペース認識**: コマンドは、現在のディレクトリおよびその他のワークスペースディレクトリでパスを検索します。ワークスペース内であれば絶対パスも許可されます。
- **処理順序**: ファイルコンテンツ注入と `@{...}` は、シェルコマンド（`!{...}`）および引数置換（`{{args}}`）_よりも前_に処理されます。
- **解析**: パーサーは、`@{...}` 内のコンテンツ（パス）がバランスの取れたブレース（`{` と `}`）を持つ必要があります。

**例 (`review.toml`):**

このコマンドは、_固定された_ベストプラクティスファイル（`docs/best-practices.md`）のコンテンツを注入し、ユーザーの引数を使用してレビューのコンテキストを提供します。

```toml
# In: <project>/.gemini/commands/review.toml
# 呼び出し方法: /review FileCommandLoader.ts

description = "ベストプラクティスガイドを使用して、提供されたコンテキストをレビューします。"
prompt = """
あなたは専門のコードレビュー担当者です。

あなたのタスクは、{{args}} をレビューすることです。

レビューを提供する際には、次のベストプラクティスを使用してください。

@{docs/best-practices.md}
"""
```

`/review FileCommandLoader.ts` を実行すると、`@{docs/best-practices.md}` プレースホルダーがそのファイルのコンテンツに置き換えられ、`{{args}}` が提供したテキストに置き換えられてから、最終プロンプトがモデルに送信されます。

---

## 例: 「純粋関数」のリファクタリングコマンド

コードの一部をリファクタリングするようにモデルに依頼するグローバルコマンドを作成しましょう。

**1. ファイルとディレクトリを作成します。**

まず、ユーザーコマンドディレクトリが存在することを確認し、次に整理のために `refactor` サブディレクトリと最終的な TOML ファイルを作成します。

```bash
mkdir -p ~/.gemini/commands/refactor
touch ~/.gemini/commands/refactor/pure.toml
```

**2. ファイルにコンテンツを追加します。**

エディターで `~/.gemini/commands/refactor/pure.toml` を開き、次のコンテンツを追加します。ベストプラクティスのためにオプションの `description` を含めます。

```toml
# In: ~/.gemini/commands/refactor/pure.toml
# このコマンドは次のように呼び出されます: /refactor:pure

description = "現在のコンテキストのコードを純粋関数にリファクタリングするようにモデルに依頼します。"

prompt = """
現在のコンテキストで提供されたコードを分析してください。
それを純粋関数にリファクタリングしてください。

応答には以下を含めてください。
1. リファクタリングされた純粋関数コードブロック。
2. 行った主要な変更とその純粋性への貢献に関する簡単な説明。
"""
```

**3. コマンドを実行します。**

それだけです！CLI でコマンドを実行できるようになりました。まず、ファイルをコンテキストに追加してから、コマンドを呼び出すことができます。

```
> @my-messy-function.js
> /refactor:pure
```

Gemini CLI は、TOML ファイルで定義された複数行のプロンプトを実行します。

```