# メモリインポートプロセッサ

メモリインポートプロセッサは、`@file.md` 構文を使用して他のファイルからコンテンツをインポートすることで、GEMINI.md ファイルをモジュール化できる機能です。

## 概要

この機能を使用すると、大きな GEMINI.md ファイルをより小さく、より管理しやすいコンポーネントに分割でき、さまざまなコンテキストで再利用できます。インポートプロセッサは、相対パスと絶対パスの両方をサポートしており、循環インポートを防ぎ、ファイルアクセスセキュリティを確保するための組み込みの安全機能が備わっています。

## 構文

`@` シンボルの後に、インポートしたいファイルのパスを使用します。

```markdown
# メインの GEMINI.md ファイル

これはメインコンテンツです。

@./components/instructions.md

ここにさらにコンテンツがあります。

@./shared/configuration.md
```

## サポートされているパス形式

### 相対パス

- `@./file.md` - 同じディレクトリからインポート
- `@../file.md` - 親ディレクトリからインポート
- `@./components/file.md` - サブディレクトリからインポート

### 絶対パス

- `@/absolute/path/to/file.md` - 絶対パスを使用してインポート

## 例

### 基本的なインポート

```markdown
# 私の GEMINI.md

私のプロジェクトへようこそ！

@./get-started.md

## 機能

@./features/overview.md
```

### ネストされたインポート

インポートされたファイル自体にインポートを含めることができ、ネストされた構造を作成します。

```markdown
# main.md

@./header.md @./content.md @./footer.md
```

```markdown
# header.md

# プロジェクトヘッダー

@./shared/title.md
```

## 安全機能

### 循環インポートの検出

プロセッサは循環インポートを自動的に検出し、防止します。

```markdown
# file-a.md

@./file-b.md

# file-b.md

@./file-a.md <!-- これは検出され、防止されます -->
```

### ファイルアクセスセキュリティ

`validateImportPath` 関数は、インポートが指定されたディレクトリからのみ許可されることを保証し、許可されたスコープ外の機密ファイルへのアクセスを防ぎます。

### 最大インポート深度

無限再帰を防ぐために、設定可能な最大インポート深度（デフォルト: 5レベル）があります。

## エラー処理

### ファイルが見つからない

参照されたファイルが存在しない場合、出力にエラーコメントが追加され、インポートは正常に失敗します。

### ファイルアクセスエラー

権限の問題やその他のファイルシステムエラーは、適切なエラーメッセージで正常に処理されます。

## コード領域の検出

インポートプロセッサは `marked` ライブラリを使用してコードブロックとインラインコードスパンを検出し、これらの領域内の `@` インポートが適切に無視されるようにします。これにより、ネストされたコードブロックや複雑な Markdown 構造を堅牢に処理できます。

## インポートツリー構造

プロセッサは、Claude の `/memory` 機能と同様に、インポートされたファイルの階層を示すインポートツリーを返します。これは、読み取られたファイルとそのインポート関係を示すことで、ユーザーが GEMINI.md ファイルの問題をデバッグするのに役立ちます。

ツリー構造の例:

```
Memory Files
 L project: GEMINI.md
            L a.md
              L b.md
                L c.md
              L d.md
                L e.md
                  L f.md
            L included.md
```

ツリーはファイルがインポートされた順序を保持し、デバッグのために完全なインポートチェーンを表示します。

## Claude Code の `/memory` (`claude.md`) アプローチとの比較

Claude Code の `/memory` 機能（`claude.md` で見られるように）は、含まれるすべてのファイルを連結してフラットで線形のドキュメントを生成し、常に明確なコメントとパス名でファイルの境界をマークします。インポート階層は明示的に提示されませんが、LLM はすべてのファイルコンテンツとパスを受信するため、必要に応じて階層を再構築するのに十分です。

> [!NOTE] インポートツリーは主に開発中の明確さのためであり、LLM の消費とは限定的な関連性しかありません。

## API リファレンス

### `processImports(content, basePath, debugMode?, importState?)`

GEMINI.md コンテンツ内のインポートステートメントを処理します。

**パラメータ:**

- `content` (string): インポートを処理するコンテンツ
- `basePath` (string): 現在のファイルが置かれているディレクトリパス
- `debugMode` (boolean, optional): デバッグログを有効にするかどうか (デフォルト: false)
- `importState` (ImportState, optional): 循環インポート防止のための状態追跡

**戻り値:** Promise&lt;ProcessImportsResult&gt; - 処理されたコンテンツとインポートツリーを含むオブジェクト

### `ProcessImportsResult`

```typescript
interface ProcessImportsResult {
  content: string; // インポートが解決された処理済みコンテンツ
  importTree: MemoryFile; // インポート階層を示すツリー構造
}
```

### `MemoryFile`

```typescript
interface MemoryFile {
  path: string; // ファイルパス
  imports?: MemoryFile[]; // 直接インポート、インポートされた順序で
}
```

### `validateImportPath(importPath, basePath, allowedDirectories)`

インポートパスを検証し、安全であり、許可されたディレクトリ内にあることを確認します。

**パラメータ:**

- `importPath` (string): 検証するインポートパス
- `basePath` (string): 相対パスを解決するためのベースディレクトリ
- `allowedDirectories` (string[]): 許可されたディレクトリパスの配列

**戻り値:** boolean - インポートパスが有効かどうか

### `findProjectRoot(startDir)`

指定された開始ディレクトリから上に `.git` ディレクトリを検索して、プロジェクトルートを見つけます。Node.js イベントループをブロックしないように、非ブロッキングファイルシステム API を使用する**非同期**関数として実装されています。

**パラメータ:**

- `startDir` (string): 検索を開始するディレクトリ

**戻り値:** Promise&lt;string&gt; - プロジェクトルートディレクトリ（`.git` が見つからない場合は開始ディレクトリ）

## ベストプラクティス

1. **インポートされたコンポーネントにはわかりやすいファイル名を使用する**
2. **インポートは浅く保つ** - 深くネストされたインポートチェーンを避ける
3. **構造を文書化する** - インポートされたファイルの明確な階層を維持する
4. **インポートをテストする** - 参照されているすべてのファイルが存在し、アクセス可能であることを確認する
5. **ポータビリティを向上させるために可能な場合は相対パスを使用する**

## トラブルシューティング

### よくある問題

1. **インポートが機能しない**: ファイルが存在し、パスが正しいことを確認する
2. **循環インポートの警告**: 循環参照がないかインポート構造を確認する
3. **権限エラー**: ファイルが読み取り可能で、許可されたディレクトリ内にあることを確認する
4. **パス解決の問題**: 相対パスが正しく解決しない場合は絶対パスを使用する

### デバッグモード

デバッグモードを有効にして、インポートプロセスの詳細なログを確認します。

```typescript
const result = await processImports(content, basePath, true);
```